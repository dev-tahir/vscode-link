# VS CODE EXTENSION: TERMINAL COMMAND HANDLING SKILL

## OVERVIEW
This skill covers creating VS Code extensions that can show and execute terminal commands with full terminal-related functionality. Updated with latest VS Code API patterns (2024-2025).

## CORE CONCEPTS

### 1. TERMINAL API BASICS
The VS Code Extension API provides three main approaches for terminal interaction:
- **Basic Terminal**: `window.createTerminal()` - Simple terminal creation and command execution
- **Pseudoterminal**: Full control over terminal input/output using `Pseudoterminal` interface
- **Shell Integration**: Read command output and execution status using shell integration events

### 2. KEY API NAMESPACES
```typescript
import * as vscode from 'vscode';

// Main terminal APIs:
vscode.window.createTerminal()           // Create standard terminal
vscode.window.terminals                  // Array of all terminals
vscode.window.activeTerminal             // Currently active terminal
vscode.window.onDidChangeActiveTerminal  // Terminal focus events
vscode.window.onDidOpenTerminal          // Terminal opened event
vscode.window.onDidCloseTerminal         // Terminal closed event
```

## IMPLEMENTATION PATTERNS

### PATTERN 1: BASIC TERMINAL WITH COMMAND EXECUTION

**Use Case**: Simple command execution with visual feedback

```typescript
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    // Register command to execute terminal commands
    let disposable = vscode.commands.registerCommand('extension.runCommand', async () => {
        // Get or create terminal
        const terminal = vscode.window.createTerminal({
            name: 'Extension Terminal',
            cwd: vscode.workspace.workspaceFolders?.[0].uri.fsPath,
            env: {
                // Custom environment variables
                'MY_VAR': 'value'
            }
        });
        
        // Show the terminal
        terminal.show(false); // false = don't steal focus
        
        // Execute commands
        terminal.sendText('echo "Starting task..."');
        terminal.sendText('npm install');
        terminal.sendText('npm run build');
    });
    
    context.subscriptions.push(disposable);
}
```

**Key Points**:
- `sendText()` simulates typing - it does NOT return output
- Commands execute asynchronously
- Cannot directly capture command output with this approach
- Use `show(preserveFocus)` to control focus behavior

### PATTERN 2: PSEUDOTERMINAL FOR FULL CONTROL

**Use Case**: Custom terminal with complete control over input/output

```typescript
import * as vscode from 'vscode';
import * as cp from 'child_process';

class CustomTerminal implements vscode.Pseudoterminal {
    private writeEmitter = new vscode.EventEmitter<string>();
    onDidWrite: vscode.Event<string> = this.writeEmitter.event;
    
    private closeEmitter = new vscode.EventEmitter<number | void>();
    onDidClose: vscode.Event<number | void> = this.closeEmitter.event;
    
    private process: cp.ChildProcess | undefined;
    
    open(initialDimensions: vscode.TerminalDimensions | undefined): void {
        // Terminal is ready
        this.writeEmitter.fire('Custom Terminal Ready!\r\n');
        this.writeEmitter.fire('$ ');
    }
    
    close(): void {
        // Clean up
        if (this.process) {
            this.process.kill();
        }
    }
    
    handleInput(data: string): void {
        // Handle user input
        if (data === '\r') { // Enter key
            this.writeEmitter.fire('\r\n');
            this.executeCommand();
        } else if (data === '\u007F') { // Backspace
            this.writeEmitter.fire('\b \b');
        } else {
            this.writeEmitter.fire(data);
        }
    }
    
    private executeCommand(): void {
        // Execute actual shell command
        const command = 'echo "Hello from pseudoterminal"';
        
        this.process = cp.exec(command, {
            cwd: vscode.workspace.workspaceFolders?.[0].uri.fsPath
        }, (error, stdout, stderr) => {
            if (error) {
                this.writeEmitter.fire(`Error: ${error.message}\r\n`);
            }
            if (stdout) {
                this.writeEmitter.fire(stdout.replace(/\n/g, '\r\n'));
            }
            if (stderr) {
                this.writeEmitter.fire(`\x1b[31m${stderr}\x1b[0m\r\n`); // Red text
            }
            this.writeEmitter.fire('$ ');
        });
    }
    
    // Optional: Handle terminal resize
    setDimensions(dimensions: vscode.TerminalDimensions): void {
        // React to terminal size changes
    }
}

// Create terminal with custom pty
const pty = new CustomTerminal();
const terminal = vscode.window.createTerminal({
    name: 'Custom Terminal',
    pty: pty
});
terminal.show();
```

**ANSI Escape Codes for Styling**:
```typescript
// Colors
'\x1b[31m' // Red
'\x1b[32m' // Green
'\x1b[33m' // Yellow
'\x1b[34m' // Blue
'\x1b[0m'  // Reset

// Cursor control
'\r'      // Carriage return (move to start of line)
'\n'      // New line
'\r\n'    // Both (required for proper line breaks in terminal)
'\b'      // Backspace
```

### PATTERN 3: SHELL INTEGRATION FOR COMMAND OUTPUT

**Use Case**: Execute commands and capture their output (VS Code 1.93+)

```typescript
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    // Monitor shell integration activation
    context.subscriptions.push(
        vscode.window.onDidChangeTerminalShellIntegration(async (event) => {
            const { terminal, shellIntegration } = event;
            
            if (!shellIntegration) {
                return; // Shell integration not available
            }
            
            vscode.window.showInformationMessage(`Shell integration activated for: ${terminal.name}`);
        })
    );
    
    // Monitor command execution
    context.subscriptions.push(
        vscode.window.onDidStartTerminalShellExecution(async (event) => {
            const execution = event.execution;
            vscode.window.showInformationMessage(`Command started: ${execution.commandLine.value}`);
        })
    );
    
    // Monitor command completion
    context.subscriptions.push(
        vscode.window.onDidEndTerminalShellExecution(async (event) => {
            const execution = event.execution;
            const exitCode = event.exitCode;
            
            // Read command output
            const stream = execution.read();
            let output = '';
            
            for await (const data of stream) {
                output += data;
            }
            
            vscode.window.showInformationMessage(
                `Command finished with exit code ${exitCode}: ${output.substring(0, 100)}`
            );
        })
    );
    
    // Execute command with shell integration
    let disposable = vscode.commands.registerCommand('extension.runWithOutput', async () => {
        const terminals = vscode.window.terminals;
        let terminal = terminals.find(t => t.shellIntegration !== undefined);
        
        if (!terminal) {
            terminal = vscode.window.createTerminal({ name: 'Output Terminal' });
            terminal.show();
            
            // Wait for shell integration to activate
            await new Promise<void>((resolve) => {
                const disposable = vscode.window.onDidChangeTerminalShellIntegration((e) => {
                    if (e.terminal === terminal) {
                        disposable.dispose();
                        resolve();
                    }
                });
            });
        }
        
        if (terminal.shellIntegration) {
            // Execute command through shell integration
            const execution = terminal.shellIntegration.executeCommand('echo "Hello World"');
            
            // Wait for completion
            const stream = execution.read();
            let output = '';
            
            for await (const data of stream) {
                output += data;
            }
            
            vscode.window.showInformationMessage(`Output: ${output}`);
        }
    });
    
    context.subscriptions.push(disposable);
}
```

**Important Notes**:
- Shell integration requires VS Code 1.93+ 
- Supported shells: zsh, bash, fish, PowerShell 7+
- May not work in all environments (check `terminal.shellIntegration`)
- Better alternative to parsing terminal output manually

### PATTERN 4: USING CHILD_PROCESS FOR DIRECT EXECUTION

**Use Case**: Execute commands without showing terminal UI

```typescript
import * as vscode from 'vscode';
import * as cp from 'child_process';
import { promisify } from 'util';

const exec = promisify(cp.exec);

async function runCommandSilently(command: string): Promise<string> {
    try {
        const { stdout, stderr } = await exec(command, {
            cwd: vscode.workspace.workspaceFolders?.[0].uri.fsPath,
            env: process.env
        });
        
        if (stderr) {
            vscode.window.showWarningMessage(`Warning: ${stderr}`);
        }
        
        return stdout;
    } catch (error: any) {
        vscode.window.showErrorMessage(`Command failed: ${error.message}`);
        throw error;
    }
}

// For long-running commands with progress
async function runCommandWithProgress(command: string): Promise<void> {
    return vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: "Running command...",
        cancellable: true
    }, async (progress, token) => {
        return new Promise<void>((resolve, reject) => {
            const child = cp.spawn(command, [], {
                shell: true,
                cwd: vscode.workspace.workspaceFolders?.[0].uri.fsPath
            });
            
            token.onCancellationRequested(() => {
                child.kill();
                reject(new Error('Command cancelled'));
            });
            
            child.stdout?.on('data', (data) => {
                progress.report({ message: data.toString() });
            });
            
            child.on('close', (code) => {
                if (code === 0) {
                    resolve();
                } else {
                    reject(new Error(`Command exited with code ${code}`));
                }
            });
        });
    });
}
```

**When to Use child_process vs Terminal**:
- Use `child_process` when:
  - Output needs programmatic processing
  - UI shouldn't show terminal
  - Need synchronous execution guarantees
  - Building automated workflows

- Use Terminal API when:
  - User should see command execution
  - Interactive commands (require user input)
  - Long-running processes that benefit from terminal UI
  - Teaching/demonstrating workflow

### PATTERN 5: TERMINAL PROFILE CONTRIBUTION

**Use Case**: Add custom terminal profiles for users to select

```json
// package.json
{
    "contributes": {
        "terminal": {
            "profiles": [
                {
                    "id": "my-extension.custom-terminal",
                    "title": "My Custom Terminal",
                    "icon": "terminal"
                }
            ]
        }
    },
    "activationEvents": [
        "onTerminalProfile:my-extension.custom-terminal"
    ]
}
```

```typescript
// extension.ts
export function activate(context: vscode.ExtensionContext) {
    // Handle terminal profile creation
    vscode.window.registerTerminalProfileProvider('my-extension.custom-terminal', {
        provideTerminalProfile(token: vscode.CancellationToken): vscode.ProviderResult<vscode.TerminalProfile> {
            return new vscode.TerminalProfile({
                name: 'Custom Terminal',
                shellPath: '/bin/bash',
                shellArgs: ['-l'],
                env: {
                    'CUSTOM_VAR': 'custom_value'
                }
            });
        }
    });
}
```

## COMMON PATTERNS & BEST PRACTICES

### 1. MANAGING MULTIPLE TERMINALS

```typescript
class TerminalManager {
    private terminals: Map<string, vscode.Terminal> = new Map();
    
    getOrCreate(name: string): vscode.Terminal {
        let terminal = this.terminals.get(name);
        
        // Check if terminal still exists
        if (terminal && vscode.window.terminals.includes(terminal)) {
            return terminal;
        }
        
        // Create new terminal
        terminal = vscode.window.createTerminal(name);
        this.terminals.set(name, terminal);
        
        return terminal;
    }
    
    disposeAll(): void {
        this.terminals.forEach(terminal => terminal.dispose());
        this.terminals.clear();
    }
}
```

### 2. WAITING FOR COMMAND COMPLETION (Workaround without shell integration)

```typescript
async function executeAndWait(terminal: vscode.Terminal, command: string): Promise<void> {
    const marker = `COMMAND_COMPLETE_${Date.now()}`;
    
    return new Promise((resolve) => {
        // Create temporary terminal for output
        const outputChannel = vscode.window.createOutputChannel('Command Output');
        
        // Execute command with marker
        terminal.sendText(`${command} && echo "${marker}"`);
        
        // Listen for terminal writes (not reliable, but a workaround)
        const disposable = vscode.window.onDidWriteTerminalData(e => {
            if (e.terminal === terminal && e.data.includes(marker)) {
                disposable.dispose();
                resolve();
            }
        });
    });
}
```

**Note**: This is a workaround. Use shell integration for reliable command completion detection.

### 3. TERMINAL CONTEXT MENU CONTRIBUTIONS

```json
// package.json
{
    "contributes": {
        "commands": [
            {
                "command": "extension.runInTerminal",
                "title": "Run Custom Command"
            }
        ],
        "menus": {
            "terminal/context": [
                {
                    "command": "extension.runInTerminal",
                    "group": "1_create"
                }
            ],
            "terminal/title/context": [
                {
                    "command": "extension.runInTerminal",
                    "group": "1_create"
                }
            ]
        }
    }
}
```

### 4. ENVIRONMENT VARIABLE MANAGEMENT

```typescript
export function activate(context: vscode.ExtensionContext) {
    // Modify environment for all future terminals
    const collection = context.environmentVariableCollection;
    
    // Add variables
    collection.replace('MY_EXTENSION_VAR', 'value');
    collection.append('PATH', ':/custom/path');
    collection.prepend('PATH', '/custom/path:');
    
    // Clear on deactivation
    context.subscriptions.push({
        dispose: () => collection.clear()
    });
}
```

### 5. TERMINAL SHELL INTEGRATION CHECK

```typescript
function checkShellIntegration(): boolean {
    const terminals = vscode.window.terminals;
    
    for (const terminal of terminals) {
        if (terminal.shellIntegration) {
            return true;
        }
    }
    
    return false;
}

async function ensureShellIntegration(): Promise<vscode.Terminal> {
    let terminal = vscode.window.terminals.find(t => t.shellIntegration);
    
    if (!terminal) {
        terminal = vscode.window.createTerminal('Shell Integration Terminal');
        terminal.show();
        
        // Wait for shell integration
        await new Promise<void>((resolve, reject) => {
            const timeout = setTimeout(() => {
                disposable.dispose();
                reject(new Error('Shell integration timeout'));
            }, 5000);
            
            const disposable = vscode.window.onDidChangeTerminalShellIntegration((e) => {
                if (e.terminal === terminal && e.shellIntegration) {
                    clearTimeout(timeout);
                    disposable.dispose();
                    resolve();
                }
            });
        });
    }
    
    return terminal;
}
```

## COMPLETE EXAMPLE: COMMAND RUNNER EXTENSION

```typescript
// extension.ts
import * as vscode from 'vscode';
import * as cp from 'child_process';

interface CommandConfig {
    name: string;
    command: string;
    cwd?: string;
    showTerminal?: boolean;
}

class CommandRunner {
    private terminal: vscode.Terminal | undefined;
    private outputChannel: vscode.OutputChannel;
    
    constructor() {
        this.outputChannel = vscode.window.createOutputChannel('Command Runner');
    }
    
    async runCommand(config: CommandConfig): Promise<void> {
        if (config.showTerminal) {
            await this.runInTerminal(config);
        } else {
            await this.runSilently(config);
        }
    }
    
    private async runInTerminal(config: CommandConfig): Promise<void> {
        // Reuse or create terminal
        if (!this.terminal || !vscode.window.terminals.includes(this.terminal)) {
            this.terminal = vscode.window.createTerminal({
                name: config.name,
                cwd: config.cwd || vscode.workspace.workspaceFolders?.[0].uri.fsPath
            });
        }
        
        this.terminal.show();
        this.terminal.sendText(config.command);
        
        // Try to use shell integration for output
        if (this.terminal.shellIntegration) {
            const execution = this.terminal.shellIntegration.executeCommand(config.command);
            const stream = execution.read();
            
            for await (const data of stream) {
                this.outputChannel.appendLine(data);
            }
        }
    }
    
    private async runSilently(config: CommandConfig): Promise<void> {
        return new Promise((resolve, reject) => {
            const process = cp.exec(config.command, {
                cwd: config.cwd || vscode.workspace.workspaceFolders?.[0].uri.fsPath
            }, (error, stdout, stderr) => {
                if (error) {
                    this.outputChannel.appendLine(`Error: ${error.message}`);
                    vscode.window.showErrorMessage(`Command failed: ${error.message}`);
                    reject(error);
                    return;
                }
                
                if (stdout) {
                    this.outputChannel.appendLine(stdout);
                }
                
                if (stderr) {
                    this.outputChannel.appendLine(`stderr: ${stderr}`);
                }
                
                vscode.window.showInformationMessage(`Command completed: ${config.name}`);
                resolve();
            });
        });
    }
    
    dispose(): void {
        this.terminal?.dispose();
        this.outputChannel.dispose();
    }
}

export function activate(context: vscode.ExtensionContext) {
    const runner = new CommandRunner();
    
    // Register commands
    context.subscriptions.push(
        vscode.commands.registerCommand('extension.runBuild', async () => {
            await runner.runCommand({
                name: 'Build',
                command: 'npm run build',
                showTerminal: true
            });
        })
    );
    
    context.subscriptions.push(
        vscode.commands.registerCommand('extension.runTest', async () => {
            await runner.runCommand({
                name: 'Test',
                command: 'npm test',
                showTerminal: false
            });
        })
    );
    
    context.subscriptions.push(runner);
}

export function deactivate() {
    // Cleanup happens automatically via subscriptions
}
```

## PACKAGE.JSON CONFIGURATION

```json
{
    "name": "terminal-command-extension",
    "displayName": "Terminal Command Runner",
    "description": "Execute and manage terminal commands",
    "version": "1.0.0",
    "engines": {
        "vscode": "^1.93.0"
    },
    "categories": ["Other"],
    "activationEvents": [
        "onCommand:extension.runBuild",
        "onCommand:extension.runTest"
    ],
    "main": "./out/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "extension.runBuild",
                "title": "Run Build Command",
                "category": "Terminal"
            },
            {
                "command": "extension.runTest",
                "title": "Run Test Command",
                "category": "Terminal"
            }
        ],
        "menus": {
            "commandPalette": [
                {
                    "command": "extension.runBuild",
                    "when": "workspaceFolderCount > 0"
                },
                {
                    "command": "extension.runTest",
                    "when": "workspaceFolderCount > 0"
                }
            ]
        }
    },
    "scripts": {
        "vscode:prepublish": "npm run compile",
        "compile": "tsc -p ./",
        "watch": "tsc -watch -p ./"
    },
    "devDependencies": {
        "@types/node": "^20.x",
        "@types/vscode": "^1.93.0",
        "typescript": "^5.x"
    }
}
```

## DEBUGGING & TESTING

### Testing Terminal Extensions

```typescript
// test/suite/extension.test.ts
import * as assert from 'assert';
import * as vscode from 'vscode';

suite('Terminal Extension Test Suite', () => {
    test('Should create terminal', async () => {
        const terminal = vscode.window.createTerminal('Test Terminal');
        assert.ok(terminal);
        
        // Verify terminal exists
        const terminals = vscode.window.terminals;
        assert.ok(terminals.some(t => t.name === 'Test Terminal'));
        
        // Cleanup
        terminal.dispose();
    });
    
    test('Should execute command', async function() {
        this.timeout(5000); // Increase timeout for async operations
        
        const terminal = vscode.window.createTerminal('Test Terminal');
        terminal.show();
        
        // Wait for terminal to be ready
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        terminal.sendText('echo "test"');
        
        // Cleanup
        terminal.dispose();
    });
});
```

### Launch Configuration

```json
// .vscode/launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Run Extension",
            "type": "extensionHost",
            "request": "launch",
            "args": [
                "--extensionDevelopmentPath=${workspaceFolder}"
            ],
            "outFiles": [
                "${workspaceFolder}/out/**/*.js"
            ],
            "preLaunchTask": "npm: watch"
        },
        {
            "name": "Extension Tests",
            "type": "extensionHost",
            "request": "launch",
            "args": [
                "--extensionDevelopmentPath=${workspaceFolder}",
                "--extensionTestsPath=${workspaceFolder}/out/test/suite/index"
            ],
            "outFiles": [
                "${workspaceFolder}/out/test/**/*.js"
            ],
            "preLaunchTask": "npm: watch"
        }
    ]
}
```

## TROUBLESHOOTING

### Common Issues

1. **Terminal commands not executing**
   - Ensure terminal is shown: `terminal.show()`
   - Check workspace folder exists
   - Verify shell path is valid

2. **Cannot capture command output**
   - Use shell integration (VS Code 1.93+)
   - Or use `child_process.exec()` instead of terminal
   - Check shell is supported (bash, zsh, fish, PowerShell 7+)

3. **Shell integration not working**
   - Verify VS Code version >= 1.93
   - Check shell is supported
   - Review terminal settings
   - May need manual shell integration setup

4. **Environment variables not applying**
   - Use `context.environmentVariableCollection`
   - Remember variables apply to NEW terminals only
   - Check timing - set before terminal creation

5. **Terminal closes unexpectedly**
   - Check for shell errors in command
   - Verify shell is properly installed
   - Review terminal output for error messages

## PERFORMANCE CONSIDERATIONS

1. **Reuse terminals** instead of creating many
2. **Dispose unused terminals** to free resources
3. **Use child_process** for background tasks
4. **Limit shell integration listeners** - clean up when done
5. **Batch commands** with `&&` or `;` when possible

## SECURITY CONSIDERATIONS

1. **Sanitize user input** before executing commands
2. **Avoid eval** or dynamic code execution
3. **Validate file paths** before using in commands
4. **Use environment variables** for sensitive data
5. **Warn users** before executing potentially dangerous commands

## ADDITIONAL RESOURCES

- VS Code Extension API: https://code.visualstudio.com/api
- Terminal API Reference: https://code.visualstudio.com/api/references/vscode-api#window
- Shell Integration: https://code.visualstudio.com/docs/terminal/shell-integration
- Extension Samples: https://github.com/microsoft/vscode-extension-samples
- Terminal Sample: https://github.com/microsoft/vscode-extension-samples/tree/main/terminal-sample

## VERSION COMPATIBILITY

- Basic Terminal API: VS Code 1.0+
- Pseudoterminal: VS Code 1.40+
- Shell Integration: VS Code 1.93+
- Terminal Profiles: VS Code 1.55+
- Environment Collection: VS Code 1.57+

Always check API availability before using newer features!